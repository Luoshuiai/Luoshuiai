[{"content":" 起因  想要建立自己的一个知识库，离线保存有价值网页内容 小众软件中的讨论，参见评论  保存手段   保存为html\n 插件 singlefile 插件 save page we    保存为PDF\n 插件 简悦 插件 adobe acrobat    考虑要素  管理软件  存储在 zotero 中 开源软件 多平台   搜索方式  zotero 支持 PDF内搜索 避免使用使用第三方搜索（anytext、filelocator）检索 html   存储  zotero 支持 webdav 同步     相关笔记  [[需要一个网页管理软件]]  ","permalink":"https://fhlp.me/posts/pkm/%E7%BD%91%E9%A1%B5%E7%9F%A5%E8%AF%86%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/","summary":" 起因  想要建立自己的一个知识库，离线保存有价值网页内容 小众软件中的讨论，参见评论  保存手段   保存为html\n 插件 singlefile 插件 save page we    保存为PDF\n 插件 简悦 插件 adobe acrobat    考虑要素  管理软件  存储在 zotero 中 开源软件 多平台   搜索方式  zotero 支持 PDF内搜索 避免使用使用第三方搜索（anytext、filelocator）检索 html   存储  zotero 支持 webdav 同步     相关笔记  [[需要一个网页管理软件]]  ","title":"网页知识库的搭建"},{"content":" 来源  How to gain control of your free time | Laura Vanderkam - YouTube  首要任务  我们不是通过节省时间来打造我们想过的生活。我们应该先建立我们想要的生活，时间就会自然而然节省出来 错误做法：通过挤海绵一样在各种省点时间堆积起来作想做的事情 正确思路：时间会自己调整，花时间做那些火烧眉头的事情  如何找出最重要的事情  思考今年的目标，是哪三到五件事让你这一年，表现出色 建立三个列表：事业、人际关系、个人 每个列表包含在年底会让你今年一年表现出色的两到三件事情 每周提前计划下一周安排，完成这些事情  技巧  在周五下午计划这些事情，因为周五下午是”低机会成本时间“  关于时间管理的数学  一周168小时 全职工作，一周40小时 每天睡眠8小时，一周56小时 还有剩余的72小时，来安排你的首要任务   相关笔记 ","permalink":"https://fhlp.me/posts/timemanagement/%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%97%B6%E9%97%B4/","summary":" 来源  How to gain control of your free time | Laura Vanderkam - YouTube  首要任务  我们不是通过节省时间来打造我们想过的生活。我们应该先建立我们想要的生活，时间就会自然而然节省出来 错误做法：通过挤海绵一样在各种省点时间堆积起来作想做的事情 正确思路：时间会自己调整，花时间做那些火烧眉头的事情  如何找出最重要的事情  思考今年的目标，是哪三到五件事让你这一年，表现出色 建立三个列表：事业、人际关系、个人 每个列表包含在年底会让你今年一年表现出色的两到三件事情 每周提前计划下一周安排，完成这些事情  技巧  在周五下午计划这些事情，因为周五下午是”低机会成本时间“  关于时间管理的数学  一周168小时 全职工作，一周40小时 每天睡眠8小时，一周56小时 还有剩余的72小时，来安排你的首要任务   相关笔记 ","title":"如何掌控你的时间"},{"content":" 需求 一定要有  开箱即用 保存有价值的网页 图形化界面方便操作 自定义分类类别 本地离线化、第三方同步  可以有  知识共享 可以添加笔记  满足需求的产品及存在缺点  zotero  个人库无法共享 团队库储存收费   obsidian  本地功能简单 实现想要的功能需要付出大量时间     相关笔记 [[网页知识库的搭建]]\n","permalink":"https://fhlp.me/posts/pkm/%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/","summary":"需求 一定要有  开箱即用 保存有价值的网页 图形化界面方便操作 自定义分类类别 本地离线化、第三方同步  可以有  知识共享 可以添加笔记  满足需求的产品及存在缺点  zotero  个人库无法共享 团队库储存收费   obsidian  本地功能简单 实现想要的功能需要付出大量时间     相关笔记 [[网页知识库的搭建]]","title":"需要一个网页管理软件"},{"content":" 知网链接  新版知网链接：  https://kns.cnki.net/kns8/defaultresult/index?txt_1_sel=SU%24%25%3D%7C\u0026amp;kw={query} 1 https://kns.cnki.net/KNS8/DefaultResult/Index?dbcode=SCDB\u0026amp;kw={query}\u0026amp;korder=SU 2 两个链接内容有差别，自己选择合适的   旧版知网链接  https://epub.cnki.net/kns/brief/default_result.aspx?txt_1_sel=FT%24%25%3D|\u0026amp;txt_1_value1={query}\u0026amp;txt_1_special1=%25\u0026amp;txt_extension=\u0026amp;expertvalue=\u0026amp;cjfdcode=%C2%A4tid=txt_1_value1\u0026amp;dbJson=coreJson\u0026amp;dbPrefix=SCDB\u0026amp;db_opt=CJFQ%2CCJFN%2CCDFD%2CCMFD%2CCPFD%2CIPFD%2CCCND%2CCCJD%2CHBRD\u0026amp;db_value=\u0026amp;hidTabChange=\u0026amp;hidDivIDS=\u0026amp;singleDB=SCDB\u0026amp;db_codes=\u0026amp;singleDBName=\u0026amp;againConfigJson=false\u0026amp;action=scdbsearch\u0026amp;ua=1.11 3 https://kns.cnki.net/kns/brief/default_result.aspx?txt_1_sel=SU%24%25%3d%7C\u0026amp;txt_1_value1={query}\u0026amp;txt_1_special1=%25\u0026amp;txt_extension=\u0026amp;expertvalue=\u0026amp;cjfdcode=\u0026amp;currentid=txt_1_value1\u0026amp;dbJson=coreJson\u0026amp;dbPrefix=SCDB\u0026amp;db_opt=CJFQ%2CCJFN%2CCDFD%2CCMFD%2CCPFD%2CIPFD%2CCCND%2CCCJD%2CHBRD\u0026amp;db_value=\u0026amp;hidTabChange=\u0026amp;hidDivIDS=\u0026amp;singleDB=SCDB\u0026amp;db_codes=\u0026amp;singleDBName=\u0026amp;againConfigJson=false\u0026amp;action=scdbsearch\u0026amp;ua=1.11 4 两个链接内容有差别，自己选择合适的      某些网站（例如知网），无论搜索什么，地址栏URL都不会变化，请问如何找到真实的搜索URL地址？ - 老默的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 某些网站（例如知网），无论搜索什么，地址栏URL都不会变化，请问如何找到真实的搜索URL地址？ - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Alfred如何添加知网搜索? - 程引的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Alfred如何添加知网搜索? - 图灵测试满分bot的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://fhlp.me/posts/softwareuse/utools%E6%B7%BB%E5%8A%A0%E7%9F%A5%E7%BD%91%E7%9A%84%E7%BD%91%E9%A1%B5%E5%BF%AB%E5%BC%80/","summary":" 知网链接  新版知网链接：  https://kns.cnki.net/kns8/defaultresult/index?txt_1_sel=SU%24%25%3D%7C\u0026amp;kw={query} 1 https://kns.cnki.net/KNS8/DefaultResult/Index?dbcode=SCDB\u0026amp;kw={query}\u0026amp;korder=SU 2 两个链接内容有差别，自己选择合适的   旧版知网链接  https://epub.cnki.net/kns/brief/default_result.aspx?txt_1_sel=FT%24%25%3D|\u0026amp;txt_1_value1={query}\u0026amp;txt_1_special1=%25\u0026amp;txt_extension=\u0026amp;expertvalue=\u0026amp;cjfdcode=%C2%A4tid=txt_1_value1\u0026amp;dbJson=coreJson\u0026amp;dbPrefix=SCDB\u0026amp;db_opt=CJFQ%2CCJFN%2CCDFD%2CCMFD%2CCPFD%2CIPFD%2CCCND%2CCCJD%2CHBRD\u0026amp;db_value=\u0026amp;hidTabChange=\u0026amp;hidDivIDS=\u0026amp;singleDB=SCDB\u0026amp;db_codes=\u0026amp;singleDBName=\u0026amp;againConfigJson=false\u0026amp;action=scdbsearch\u0026amp;ua=1.11 3 https://kns.cnki.net/kns/brief/default_result.aspx?txt_1_sel=SU%24%25%3d%7C\u0026amp;txt_1_value1={query}\u0026amp;txt_1_special1=%25\u0026amp;txt_extension=\u0026amp;expertvalue=\u0026amp;cjfdcode=\u0026amp;currentid=txt_1_value1\u0026amp;dbJson=coreJson\u0026amp;dbPrefix=SCDB\u0026amp;db_opt=CJFQ%2CCJFN%2CCDFD%2CCMFD%2CCPFD%2CIPFD%2CCCND%2CCCJD%2CHBRD\u0026amp;db_value=\u0026amp;hidTabChange=\u0026amp;hidDivIDS=\u0026amp;singleDB=SCDB\u0026amp;db_codes=\u0026amp;singleDBName=\u0026amp;againConfigJson=false\u0026amp;action=scdbsearch\u0026amp;ua=1.11 4 两个链接内容有差别，自己选择合适的      某些网站（例如知网），无论搜索什么，地址栏URL都不会变化，请问如何找到真实的搜索URL地址？ - 老默的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 某些网站（例如知网），无论搜索什么，地址栏URL都不会变化，请问如何找到真实的搜索URL地址？ - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Alfred如何添加知网搜索? - 程引的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Alfred如何添加知网搜索? - 图灵测试满分bot的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","title":"utools添加知网的网页快开"},{"content":" 读取图片 \tcv2.imread(\u0026#39;\u0026#39;,img) 改变图片大小  cv2.resize(img, (300,300)) cv2.resize(img, (0,0),fx=0.5,fy=0.5) fx,fy 缩放倍数 读取视频 \t# 读取已经保存的视频 cv2.VideoCapture(\u0026#39;voideo.mp4\u0026#39;) # 读取镜头视频，通过编号选择镜头 # 假设笔记本有两个镜头，那么电脑自带镜头编号0，外接镜头编号1 cap = cv2.VideoCapture(1) # 逐帧显示视频 while Ture: # 读取下一帧 ret,frame=cap.read() # ret 取得下一帧是否成功 # frame 取得的下一帧 # 判断视频帧是否读取成功 if ret: # 把每帧的图像缩放0.4倍 frame = cv2.resize(frame,(0,0),fx=0.4,fy=0.4) cv2.imshow(\u0026#39;video\u0026#39;,frame) else: break # 每个十毫秒显示一帧视频，等待中按 q 中止播放 if cv2.waitkey(10) == ord(\u0026#39;q\u0026#39;): break numpy 与图片的关系 打印一张图片的类型\n\tprint(img) print(type(img)) print(img.shape) 输出： # 输出图片的详细数据 [[[255 255 255] [255 255 255] [255 255 255] ... [255 255 255] [255 255 255] [255 255 255]] [[255 255 255] [255 255 255] [255 255 255] ... [255 255 255] [255 255 255] [255 255 255]]] # 输出图片的数据类型：ndarray # ndarray 多维数组 \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; # 输出图片的维度 # 彩色图片即是RBG # 在opencv中，彩色图片颜色顺序是：B G R (474, 474, 3) 创建图片\n\timport random import cv2 import numpy as np # 创建图片 # 图片的大小 300*300 像素 # 图片的维度 3 (RGB) # np.uiunt8 设置多维数组中数的格式，uiuin8 正数 # b g r 0 255 255 img = np.empty((300, 300, 3), np.uint8) for row in range(300): for col in range(300): img[row][col] = [random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)] cv2.imshow(\u0026#39;img\u0026#39;, img) cv2.waitKey(0) 切割图片\n\t# 切割图片img # 高度坐标：0-150 像素点 宽度坐标：200-400像素点 newImg=img[:150,200:400] cv2.imshow(\u0026#39;img\u0026#39;,img) cv2.imshow(\u0026#39;newImg\u0026#39;,newImg) 常用函数 彩色图片转灰度图片\n\t参数：图片 BGR转灰度 imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) 高斯模糊\n\t# 参数：图片 高斯核 标准差 cv2.GaussianBlur(img,(5,5),0) 边缘提取\n\t# 参数：图片 LowThreshold HighThreshold cv2.canny(img, 150, 200) 图片膨胀(图片线条变粗)\n\timprot numpy as np # 膨胀核 二维数组 kernel = np.ones((3,3), np.unit8) # 参数：图片 膨胀核 膨胀次数 dilate=cv2.dilate(img, kernel, iterations = 1) 图片侵蚀(图片线条变细)\n\timprot numpy as np # 膨胀核 二维数组 kernel = np.ones((3,3), np.unit8) # 参数：图片 膨胀核 膨胀次数 erode=cv2.erode(img, kernel, iterations = 1) 在图片中画图形，写字 \timport cv2 import numpy as np # 创建图片 img = np.zeros((600, 600, 3), np.uint8) # 图片中画线 # 参数：图片 起始点坐标 终点坐标 线的颜色 线的宽度 cv2.line(img, (0, 0), (400, 400), (255, 255, 255), 1) # 画矩形 # 最后一个参数 cv2.FILED 矩形填充，如果是数字则是边缘线条宽度 cv2.rectangle(img, (0, 0), (400, 300), (255, 255, 255), cv2.FILED) # 画圆 # 参数 图片 圆心坐标 半径 边缘线条颜色 边缘线条宽度 cv2.circle(img, (400,500), 20, (255, 255, 255), 1) # 添加文字（不支持中文） # 参数：图片 添加的文字 起始点坐标 文字字体 文字大小 文字颜色 文字线条宽度 cv2.putText(img, \u0026#39;Hi\u0026#39;, (100, 500), cv2.FONT_ITALIC, 1, (255, 255, 255), 1) cv2.imshow(\u0026#39;img\u0026#39;, img) cv2.waitKey(0) 检测图片颜色 \timport cv2 import numpy as np def empty(v): pass img = cv2.imread(\u0026#39;xx,jpg\u0026#39;) img = cv2.resize(img, (0, 0), fx=1, fy=1) # 创建一个 TrackBar 控制界面 # 通过 TrackBar 手动调节检测颜色 # 把 img 从 BGR 颜色空间转换成 HSV 颜色空间 cv2.namedWindow(\u0026#39;TrackBar\u0026#39;) cv2.resizeWindow(\u0026#39;TrackBar\u0026#39;, 640, 320) cv2.createTrackbar(\u0026#39;hug min\u0026#39;, \u0026#39;TrackBar\u0026#39;, 0, 179, empty) cv2.createTrackbar(\u0026#39;hug max\u0026#39;, \u0026#39;TrackBar\u0026#39;, 179, 179, empty) cv2.createTrackbar(\u0026#39;sar min\u0026#39;, \u0026#39;TrackBar\u0026#39;, 0, 255, empty) cv2.createTrackbar(\u0026#39;sar max\u0026#39;, \u0026#39;TrackBar\u0026#39;, 255, 255, empty) cv2.createTrackbar(\u0026#39;val min\u0026#39;, \u0026#39;TrackBar\u0026#39;, 0, 255, empty) cv2.createTrackbar(\u0026#39;val max\u0026#39;, \u0026#39;TrackBar\u0026#39;, 255, 255, empty) hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # 手动选择颜色 while True: h_min = cv2.getTrackbarPos(\u0026#39;hug min\u0026#39;, \u0026#39;TrackBar\u0026#39;) h_max = cv2.getTrackbarPos(\u0026#39;hug max\u0026#39;, \u0026#39;TrackBar\u0026#39;) s_min = cv2.getTrackbarPos(\u0026#39;sar min\u0026#39;, \u0026#39;TrackBar\u0026#39;) s_max = cv2.getTrackbarPos(\u0026#39;sar max\u0026#39;, \u0026#39;TrackBar\u0026#39;) v_min = cv2.getTrackbarPos(\u0026#39;val min\u0026#39;, \u0026#39;TrackBar\u0026#39;) v_max = cv2.getTrackbarPos(\u0026#39;val max\u0026#39;, \u0026#39;TrackBar\u0026#39;) print(h_min, h_max, s_min, s_max, v_min, v_max) lower = np.array([h_min, s_min, v_min]) upper = np.array([h_max, s_max, v_max]) # 获取在 lower 与 upper 范围内的颜色 mask = cv2.inRange(hsv, lowerb=lower, upperb=upper) # 把两张图片中的每一个bit做 and 运算 # 在 img 图片中把 mask 图片过滤出来 result = cv2.bitwise_and(img, img, mask=mask) cv2.imshow(\u0026#39;img\u0026#39;, img) cv2.imshow(\u0026#39;hsv\u0026#39;, hsv) cv2.imshow(\u0026#39;msak\u0026#39;, mask) cv2.imshow(\u0026#39;result\u0026#39;, result) cv2.waitKey(1) 轮廓检测 \timport cv2 img = cv2.imread(\u0026#39;shape.jpg\u0026#39;) imgContour = img.copy() # img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) canny = cv2.Canny(img, 100, 200) # 轮廓检测 # 参数：图片 检测模式（外轮廓、内轮廓。。） 近似方法 # 返回参数：轮廓 阶层 contours, hierarchy = cv2.findContours(canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) # 把轮廓画出来 for cnt in contours: # # 参数：图片 图廓点 画的轮廓数量 颜色 宽度 cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 4) # 轮廓面积 area = cv2.contourArea(cnt) # 通过面积大小来过滤噪点 面积大于 500 对轮廓进行近似 if area \u0026gt; 500: # 轮廓边长 peri = cv2.arcLength(cnt, True) # 轮廓近似成图形 # 输入参数：轮廓 近似值 是否是封闭图形 # 输出参数：近似图形的顶点 vertices = cv2.approxPolyDP(cnt, peri * 0.02, True) # 近似轮廓顶点 corners = len(vertices) # print(vertices) # 对每个轮廓生成外接矩形 # 输出参数：需要生成外接矩形的轮廓 # 输出参数：左上角x坐标 左上角y坐标 宽度 高度 x, y, w, h = cv2.boundingRect(vertices) # 在图片中画出外接矩形 # 输入参数：图片 左上角顶点坐标 右下角顶点坐标 颜色 宽度 cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 4) # 通过近似轮廓有几个顶点判断轮廓的形状 if corners == 3: cv2.putText(imgContour, \u0026#39;Triangle\u0026#39;, (x, y - 5), cv2.FONT_ITALIC, 1, (0, 0, 255), 2) if corners == 4: cv2.putText(imgContour, \u0026#39;Rectangle\u0026#39;, (x, y - 5), cv2.FONT_ITALIC, 1, (0, 0, 255), 2) if corners == 5: cv2.putText(imgContour, \u0026#39;Pentagon\u0026#39;, (x, y - 5), cv2.FONT_ITALIC, 1, (0, 0, 255), 2) if corners \u0026gt; 5: cv2.putText(imgContour, \u0026#39;Circle\u0026#39;, (x, y - 5), cv2.FONT_ITALIC, 1, (0, 0, 255), 2) cv2.imshow(\u0026#39;img\u0026#39;, img) cv2.imshow(\u0026#39;canny\u0026#39;, canny) cv2.imshow(\u0026#39;imgContour\u0026#39;, imgContour) cv2.waitKey(0) 人脸识别 \timport cv2 img = cv2.imread(\u0026#39;lenna.jpg\u0026#39;) # 彩色图片转灰度图片 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 导入Cascade分类器 # face_detect.xml 为opencv 已经训练好的模型 faceCascade = cv2.CascadeClassifier(\u0026#39;face_detect.xml\u0026#39;) # 输入参数：图片 在多次全局搜索中图片缩小的笔记，即尺度放大的比例 最大化抑制的次数，人脸被选中三次以上才判断为人脸 faceRect = faceCascade.detectMultiScale(gray, 1.1, 3) print(len(faceRect)) for (x, y, w, h) in faceRect: cv2.rectangle(img, (x, y), (x + w, y + h), (0, 0, 255), 2) cv2.imshow(\u0026#39;img\u0026#39;, img) cv2.waitKey(0) project  通过镜头获取画面 手拿笔在镜头中运动 在窗口中标记笔的运动轨迹 对于多支笔的轨迹，通过不同颜色标记出来  \timport cv2 import numpy as np video = cv2.VideoCapture(0) # [x,y,c] drawPoints = [] def findPen(img): hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) lower = np.array([28, 35, 83]) upper = np.array([55, 255, 232]) mask = cv2.inRange(hsv, lower, upper) result = cv2.bitwise_and(img, img, mask=mask) penx, peny = findContour(mask) cv2.circle(imgContour, (penx, peny), 5, (0, 0, 255), cv2.FILLED) if peny != -1: drawPoints.append([penx, peny]) # cv2.imshow(\u0026#39;result\u0026#39;, result) def findContour(img): # 轮廓检测 # 参数：图片 检测模式（外轮廓、内轮廓。。） 近似方法 # 返回参数：轮廓 阶层 contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) x, y, w, h = 0, 0, 0, 0 # 把轮廓画出来 for cnt in contours: # # 参数：图片 图廓点 画的轮廓数量 颜色 宽度 # cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 4) # 轮廓面积 area = cv2.contourArea(cnt) # 通过面积大小来过滤噪点 面积大于 500 对轮廓进行近似 if area \u0026gt; 500: # 轮廓边长 peri = cv2.arcLength(cnt, True) # 轮廓近似成图形 # 输入参数：轮廓 近似值 是否是封闭图形 # 输出参数：近似图形的顶点 vertices = cv2.approxPolyDP(cnt, peri * 0.02, True) # print(vertices) # 对每个轮廓生成外接矩形 # 输出参数：需要生成外接矩形的轮廓 # 输出参数：左上角x坐标 左上角y坐标 宽度 高度 x, y, w, h = cv2.boundingRect(vertices) return x + w // 2, y + h // 2 def draw(drawPoints): for point in drawPoints: cv2.circle(imgContour, (point[0], point[1]), 5, (0, 0, 255), cv2.FILLED) while True: ret, frame = video.read() if ret: cv2.imshow(\u0026#39;video\u0026#39;, frame) imgContour = frame.copy() findPen(frame) draw(drawPoints) cv2.imshow(\u0026#39;contour\u0026#39;, imgContour) else: break if cv2.waitKey(1) == ord(\u0026#39;q\u0026#39;): break ","permalink":"https://fhlp.me/posts/cv/python%E7%9A%84opencv%E5%85%A5%E9%97%A8/","summary":"读取图片 \tcv2.imread(\u0026#39;\u0026#39;,img) 改变图片大小  cv2.resize(img, (300,300)) cv2.resize(img, (0,0),fx=0.5,fy=0.5) fx,fy 缩放倍数 读取视频 \t# 读取已经保存的视频 cv2.VideoCapture(\u0026#39;voideo.mp4\u0026#39;) # 读取镜头视频，通过编号选择镜头 # 假设笔记本有两个镜头，那么电脑自带镜头编号0，外接镜头编号1 cap = cv2.VideoCapture(1) # 逐帧显示视频 while Ture: # 读取下一帧 ret,frame=cap.read() # ret 取得下一帧是否成功 # frame 取得的下一帧 # 判断视频帧是否读取成功 if ret: # 把每帧的图像缩放0.4倍 frame = cv2.resize(frame,(0,0),fx=0.4,fy=0.4) cv2.imshow(\u0026#39;video\u0026#39;,frame) else: break # 每个十毫秒显示一帧视频，等待中按 q 中止播放 if cv2.waitkey(10) == ord(\u0026#39;q\u0026#39;): break numpy 与图片的关系 打印一张图片的类型\n\tprint(img) print(type(img)) print(img.shape) 输出： # 输出图片的详细数据 [[[255 255 255] [255 255 255] [255 255 255] .","title":"python的opencv入门"},{"content":" 默认描述机器视觉中的概念。\n卷积  卷积的目的是什么？→提取图像特征，去除噪点 卷积是什么？→把当前点和周围点加权平均 卷积计算公式：$$(𝑓 ∗ 𝑔)[𝑚, 𝑛] = \\sum_{k,l} 𝑓[𝑚 − 𝑘, 𝑛 − 𝑙]𝑔[𝑘, 𝑙]$$  卷积核  卷积核是什么？→当前点与周围点加权平均的权值 如何进行卷积？  对卷积核进行翻转 ⇒ 把卷积核放入图像中  把卷积核中各个点与在图像中对应点加权求和，得到中间点 e 的值 卷积核平移、下滑，对所有点进行卷积运算    卷积的特性  线性：分开求和与组合求和结果不变  Linearity: filter(f1 + f2) = filter(f1) + filter(f2)   平移不变性：先卷积再平移与先平移再卷积结果不变  Shift invariance: same behavior regardless of pixel location: filter(shift(f)) = shift(filter(f)) 结论：任何平移不变的操作都能用卷积来表示  Theoretical result: any linear shift-invariant operator can be r epresented as a convolution 图像向左平移一个像素         交换律  Commutative: $a * b = b * a$ Conceptually no difference between filter and signal   结合律  Associative: $a * (b * c) = (a * b) * c$ Often apply several filters one after another: $(((a * b1) * b2) * b3)$ This is equivalent to applying one filter: $a * (b1 * b2 * b3)$   分配律  Distributes over addition: $a * (b + c) = (a * b) + (a * c)$ Scalars factor out: $ka * b = a * kb = k (a * b)$ Identity: unit impulse $e = […, 0, 0, 1, 0, 0, …],a * e = a$    卷积为什么要翻转  模板不反转称为相关 在实际使用中，很多模板都是对称的，并不强调翻转 数学中卷积，主要是为了诸如信号处理、求两个随机变量和的分布等而定义的运算，所以需要“翻转”是根据问题的需要而确定的 卷积神经网络中“卷积”，是为了提取图像的特征，其实只借鉴了“加权求和”的特点 还有一点一定要说的是：数学中的“卷积核”都是已知的或者给定的，卷积神经网络中“卷积核”本来就是trainable的参数，不是给定的，根据数据训练学习的，那么翻不翻转还有什么关系呢？因为无论翻转与否对应的都是未知参数！ 二维卷积在图像处理中的应用就是为了提取特征，如高通滤波器提取边缘特征可以看作是一种局部特征提取，低通滤波器进行去噪平滑可以看作是一种全局特征提取，而在神经网络中对于一个图像的分类任务来说，我们并不清楚图像中哪一部位应该提取全局特征还是局部特征，因此卷积核就变成了可训练的参数，根据误差函数来确定哪一部位应该提取哪一种特征，这就是神经网络中卷积核之所以为参数的本质，以结果为导向，而不像数学中的卷积有明确的目标。  存在的问题  卷积存在的问题→对原图像进行卷积，卷积图像会比原图像小一圈     如何保证卷积图像和原图像一样大小?→需要对周围一圈进行填充 卷积常见填充方法  clip filter (black) wrap around copy edge reflect across edge   卷积填充的目的：让输入和输出的图像大小相等  ","permalink":"https://fhlp.me/posts/cv/convolutions/","summary":"默认描述机器视觉中的概念。\n卷积  卷积的目的是什么？→提取图像特征，去除噪点 卷积是什么？→把当前点和周围点加权平均 卷积计算公式：$$(𝑓 ∗ 𝑔)[𝑚, 𝑛] = \\sum_{k,l} 𝑓[𝑚 − 𝑘, 𝑛 − 𝑙]𝑔[𝑘, 𝑙]$$  卷积核  卷积核是什么？→当前点与周围点加权平均的权值 如何进行卷积？  对卷积核进行翻转 ⇒ 把卷积核放入图像中  把卷积核中各个点与在图像中对应点加权求和，得到中间点 e 的值 卷积核平移、下滑，对所有点进行卷积运算    卷积的特性  线性：分开求和与组合求和结果不变  Linearity: filter(f1 + f2) = filter(f1) + filter(f2)   平移不变性：先卷积再平移与先平移再卷积结果不变  Shift invariance: same behavior regardless of pixel location: filter(shift(f)) = shift(filter(f)) 结论：任何平移不变的操作都能用卷积来表示  Theoretical result: any linear shift-invariant operator can be r epresented as a convolution 图像向左平移一个像素         交换律  Commutative: $a * b = b * a$ Conceptually no difference between filter and signal   结合律  Associative: $a * (b * c) = (a * b) * c$ Often apply several filters one after another: $(((a * b1) * b2) * b3)$ This is equivalent to applying one filter: $a * (b1 * b2 * b3)$   分配律  Distributes over addition: $a * (b + c) = (a * b) + (a * c)$ Scalars factor out: $ka * b = a * kb = k (a * b)$ Identity: unit impulse $e = […, 0, 0, 1, 0, 0, …],a * e = a$    卷积为什么要翻转  模板不反转称为相关 在实际使用中，很多模板都是对称的，并不强调翻转 数学中卷积，主要是为了诸如信号处理、求两个随机变量和的分布等而定义的运算，所以需要“翻转”是根据问题的需要而确定的 卷积神经网络中“卷积”，是为了提取图像的特征，其实只借鉴了“加权求和”的特点 还有一点一定要说的是：数学中的“卷积核”都是已知的或者给定的，卷积神经网络中“卷积核”本来就是trainable的参数，不是给定的，根据数据训练学习的，那么翻不翻转还有什么关系呢？因为无论翻转与否对应的都是未知参数！ 二维卷积在图像处理中的应用就是为了提取特征，如高通滤波器提取边缘特征可以看作是一种局部特征提取，低通滤波器进行去噪平滑可以看作是一种全局特征提取，而在神经网络中对于一个图像的分类任务来说，我们并不清楚图像中哪一部位应该提取全局特征还是局部特征，因此卷积核就变成了可训练的参数，根据误差函数来确定哪一部位应该提取哪一种特征，这就是神经网络中卷积核之所以为参数的本质，以结果为导向，而不像数学中的卷积有明确的目标。  存在的问题  卷积存在的问题→对原图像进行卷积，卷积图像会比原图像小一圈     如何保证卷积图像和原图像一样大小?","title":"Convolutions"},{"content":"理论  知识模块=知识结构+知识点 数据库=字段+值  工具  知网词典、术语在线-\u0026gt;查询词语的准确性  流程 获取元数据（metadata） 在读秀、万方获取元信息，在emeditor中编写统一的脚本，进行处理 可以将这些数据做成自己的一个书藉库\n图片转文字处理   ABBYY FineReaderOCR. exe 主程序、FineReader. exe PDF 阅读+处理程序、HotFolder. exe 企业级批量 OCR、ScreenshotReader. exe PC 桌面 OCR\n    字体，正文一般是方正书宋体\n    预处理选项\n  ![Pasted image 20210831174245.png](C:\\Users\\luo\\OneDrive\\hugo website\\废话连篇\\content\\posts\\Read\\Pasted image 20210831174245.png)\n      高级玩法，自己设置字符集\n HT只需要4-8cpu，10G内存，可以用虚拟机来运行    PDF保存设置\n    文本处理  [[emeditor]] 处理文本  通过字符数字+非句末标点，去模糊性定位章节 如果可以找到文字性材料，一定要是aw3格式，不是epub格式（epub格式很可能是后边人制作的，不是出版社制作的） sigil，快速查看epub格式 html格式可以直接导入sm中 这个结构就是为了处理前备知识不足的问题 属于增量阅读的变种用法 我们先想想,处理书籍的时候,最核心的一点就在于《名词的积累》 名词,可以展开这个名词的属性(可以往知识图谱这个结构走) 所以,这块儿属于读书的核心,很多书,读不下去,第一关就是词汇量的问题 特别是某个,陌生领域,陌生的词汇,这个词汇不解决,你后续一堆的问题。 处理词汇的办法有好几个 常见的自动化处理,就是分词    术语名词处理  自动化分词处理：[[hanlp]] 理解一段话，一篇文章，最终要的是搞懂其中名词的含义，NPL 可以快速判断其中的名词，然后可以挑选出来，快速查找意思  ","permalink":"https://fhlp.me/posts/read/%E5%A4%84%E7%90%86%E4%B8%80%E6%9C%AC%E4%B9%A6%E7%9A%84%E6%B5%81%E7%A8%8B/","summary":"理论  知识模块=知识结构+知识点 数据库=字段+值  工具  知网词典、术语在线-\u0026gt;查询词语的准确性  流程 获取元数据（metadata） 在读秀、万方获取元信息，在emeditor中编写统一的脚本，进行处理 可以将这些数据做成自己的一个书藉库\n图片转文字处理   ABBYY FineReaderOCR. exe 主程序、FineReader. exe PDF 阅读+处理程序、HotFolder. exe 企业级批量 OCR、ScreenshotReader. exe PC 桌面 OCR\n    字体，正文一般是方正书宋体\n    预处理选项\n  ![Pasted image 20210831174245.png](C:\\Users\\luo\\OneDrive\\hugo website\\废话连篇\\content\\posts\\Read\\Pasted image 20210831174245.png)\n      高级玩法，自己设置字符集\n HT只需要4-8cpu，10G内存，可以用虚拟机来运行    PDF保存设置\n    文本处理  [[emeditor]] 处理文本  通过字符数字+非句末标点，去模糊性定位章节 如果可以找到文字性材料，一定要是aw3格式，不是epub格式（epub格式很可能是后边人制作的，不是出版社制作的） sigil，快速查看epub格式 html格式可以直接导入sm中 这个结构就是为了处理前备知识不足的问题 属于增量阅读的变种用法 我们先想想,处理书籍的时候,最核心的一点就在于《名词的积累》 名词,可以展开这个名词的属性(可以往知识图谱这个结构走) 所以,这块儿属于读书的核心,很多书,读不下去,第一关就是词汇量的问题 特别是某个,陌生领域,陌生的词汇,这个词汇不解决,你后续一堆的问题。 处理词汇的办法有好几个 常见的自动化处理,就是分词    术语名词处理  自动化分词处理：[[hanlp]] 理解一段话，一篇文章，最终要的是搞懂其中名词的含义，NPL 可以快速判断其中的名词，然后可以挑选出来，快速查找意思  ","title":"处理一本书的流程"},{"content":" 书籍的内容是各种[[词语]]的组合 通过小学初中高中语文的锻炼，我们掌握了词语和语法，能够熟练阅读理解各种文章 在我们阅读新知识的过程中，对我们阻碍最大的是实词中的名词，因为名词的数量巨大而且在不停的创造和增加，相比而言其他实词与虚词早已固定不会有过多的变化 阅读文章的过程就是把各种不认识名词串联理解的过程 所以，问题的关键，如何克服阅读过程中的名词障碍？？？  ","permalink":"https://fhlp.me/posts/read/%E9%98%85%E8%AF%BB%E4%B8%8E%E5%90%8D%E8%AF%8D%E9%9A%9C%E7%A2%8D/","summary":" 书籍的内容是各种[[词语]]的组合 通过小学初中高中语文的锻炼，我们掌握了词语和语法，能够熟练阅读理解各种文章 在我们阅读新知识的过程中，对我们阻碍最大的是实词中的名词，因为名词的数量巨大而且在不停的创造和增加，相比而言其他实词与虚词早已固定不会有过多的变化 阅读文章的过程就是把各种不认识名词串联理解的过程 所以，问题的关键，如何克服阅读过程中的名词障碍？？？  ","title":"阅读与名词障碍"},{"content":"阅读的困难  阅读的困难在于如何克服 [[阅读与名词障碍]] 所以阅读的最大障碍，如何解决术语名词的理解问题  如何解决困难  对书籍进行预处理，提取出关键术语，参考：[[处理一本书的流程]] 对关键术语进行双链引用  阅读的流程  获取书籍的关键知识点词汇及前置知识 查阅书籍的知识结构 阅读及制卡复习  ","permalink":"https://fhlp.me/posts/read/%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E7%9A%84%E6%B5%81%E7%A8%8B/","summary":"阅读的困难  阅读的困难在于如何克服 [[阅读与名词障碍]] 所以阅读的最大障碍，如何解决术语名词的理解问题  如何解决困难  对书籍进行预处理，提取出关键术语，参考：[[处理一本书的流程]] 对关键术语进行双链引用  阅读的流程  获取书籍的关键知识点词汇及前置知识 查阅书籍的知识结构 阅读及制卡复习  ","title":"阅读一本书的流程"}]